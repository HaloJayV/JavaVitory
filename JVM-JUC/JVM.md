[TOC]

# JVM体系结构

<img src="../../../../Software/Typora/Picture/image-20200622095107816.png" alt="image-20200622095107816"  />



### 类加载器(快递员)：

* 只负责加载java文件，编译后的class文件在文件开头有特定的文件表示，将class文件字节码内容从硬盘加载到JVM内存中并将这些内容转换成方法区的运行时数据结构，至于是否可以正常运行由Execution Engine决定。加载**class**后为模板**Class**，该模板存放类的结构信息，一个模板可以实例化多个实例。

* 3个classLoader：启动加载器`Bootstrap(C++)`，扩展加载器`Extension(Java)`，应用程序类加载器AppClassLoader, 分别是祖父孙, 他们都是抽象类，需要被继承。还有用户自定义加载器`Java.lang.ClassLoader`的子类，用户可以定制类的加载方式, 通过继承ClassLoader类
  
    * `new Object().getClass().getClassLoader()`为Bootstrap，是Java祖宗级，在java里输出为null
  * `new MyObject().getClass().getClassLoader()`，即自己new的类，它的加载器是AppClassLoader , 父加载器为Extension
  * classLoader双亲委派机制：当收到某个java文件的类加载请求，所有类加载请求都会传送到启动加载类，首先从根加载器(Bootstrap)开始向下寻找，如果都找不到抛ClassNotFound异常，保证了沙箱安全
  * 沙箱安全机制：由双亲委派机制实现，只加载从Bootstrap向下找到的第一个文件，保证Java的源码不被污染，即保证了相同类名时只执行原生类。
  
* 程序编译时，加载顺序：静态代码块（只会被加载一次）>构造块>构造方法

* ##### 加载(Loading)

    加载是指将类的class文件读到内存中，并为其创建一个java.lang.Class对象（每个类都有其独一无二的.Class对象)，类加载由**JVM中的类加载器**完成，且其加载一般符合"**双亲委派原则**"，除此之外，还可以自定义类加载器对类进行初始化；
    通过不同的类加载器，可以从不同的源加载类的二进制数据文件：

    > 1.从本地文件系统加载class文件。
    > 2.从JAR包加载class文件，这种方式也是很常见的，JDBC编程时用到的数据库驱动类(com.mysql.jdbc.Driver)就放 在JAR文件中，JVM可以从JAR文件中直接加载该class文件。
    > 3.通过网络加载class文件。
    > 4.把一个Java源文件动态编译，并执行加载。

* #### 类加载的双亲委派机制

    JVM在加载类的时候默认采用的是**双亲委派机制**；通俗讲就是某个特定的类加载器在接收到加载类的任务请求时，首先将加载任务委托给父类加载器进行加载，然后父类加载器又向上委托，以此类推一直到加载任务处于BootStrap Class Loader中，其中如果父类加载器可以执行加载则加载成功或直接返回，若父类没有成功加载，则由子类加载器进行加载，再次以此类推；

    ![在这里插入图片描述](../../../../Software/Typora/Picture/20190812184431215.png)

### 本地方法栈：

* Thread线程类中由native修饰的方法，代表这个方法调用的是底层操作系统和第三方C语言函数库方法, 该方法存放在本地方法栈，其他普通方法存放在java栈。`new Thread().start()` 只是新建完成到就绪状态，是否被运行决定于底层操作系统和CPU的调度
* 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
* 为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

### 方法区：java8开始叫**元空间**

* 所有线程共享，存在GC，只是量很少，大部分GC在堆里
* 供各线程共享的运行时内存区域，用于存放每一个类的结构信息，例如**运行时常量池、类信息、class的static变量**。方法区是规范，不同虚拟机实现不同，例如永久代PermGen space 和 元空间 Metaspace
* java7之前：`方法区 f = new 永久代`      java8之后移除了永久代：`方法区 f = new 元空间`

* 类的实例方法和实例对象存在堆内存中，和方法区无关

### PC寄存器（程序计数器）

* 也叫程序计数器，就是一个指针，存放下一条指令的地址，指向下一条要执行的命令，记录了方法之间的调用和执行情况

* 每个线程都有一个程序计数器，和栈一样都是线程私有的，内存很小几乎不存在GC，不会发生内存溢出

* 如果执行的是native方法，那这个计数器为空

* 程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。


### 虚拟机栈stack（Java栈）

* 栈负责运行，堆负责存储。在Java中，程序 = 框架 + 业务逻辑

* 每个 Java 方法在执行的同时会创建一个栈帧用于**存储局部变量表、操作数栈、常量池引用**等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

* 线程私有，不存在GC问题，8种基本类型变量+对象的引用变量+实例方法都是在函数的栈内存中分配

* Java方法被压到栈中，叫做栈帧， main方法最先被压栈，栈帧是内存区，是有关方法和运行期数据的数据集

* 栈帧中主要保存三类数据：（栈中的数据都是以栈帧的格式存在，在JVM栈里方法叫栈帧，在JVM外叫方法）
  * 本地变量：输入参数和输出参数以及方法内的变量
  * 栈操作：记录出栈、入栈的操作
  * 栈帧数据：包括类文件、方法等

* 栈运行原理：

  ![image-20200625150328453](../../../../Software/Typora/Picture/image-20200625150328453.png)

* 栈溢出错误SOF：StackOverflowError

* `A a = new A();`  如果是在方法里定义，则 a 放在函数的栈里；如果在class里定义，则 a 分配在堆里。

* 栈、堆和方法区的交互关系：
  * HotSpot(一个JVM)使用指针的方式来访问对象，Java堆会存放访问`类元数据`（Class模板）的地址，reference存储对象的地址
  * ![image-20200625163854917](../../../../Software/Typora/Picture/image-20200625163854917.png)

###  堆（heap）：逻辑上分为以下三部分：

* 主要用于存放新创建的对象

* ![image-20200626125947858](../../../../Software/Typora/Picture/image-20200626125947858.png)
* 1.新生代(PSYoungGen)：
  * 1.伊甸区(Eden Space): new对象存在该区，GC(也叫 YGC 或轻GC 或 MinorGC)在该区产生；在内存超过阈值时开启GC之后，除了正被引用的对象和静态变量被移动到S0区，未存活的对象 被 **JVM**清除
    * 普通MinorGC：复制(GC复制算法将存活对象复制到To区) -> 清空(Eden和from全部清空)  -> 互换(S0和S1互换，谁空谁是to区)
      * 复制：第一次GC将Eden区存活的对象复制到S0区后清空Eden区，再次GC后会扫描Eden和S0区进行GC，回收存活的对象并复制到to区(如果有对象的年龄到达老年区的标准则复制到老年区)，Eden和from区清空，同时把在To区存活的对象年龄+1，以后每次都需要扫描Eden区和S0和S1区，进行MinorGC过程
      * 清空：清空Eden和from区的对象，也即复制之后有交换，谁空谁是to区
      * 交换：To区和From区互换，部分MinorGC存活到15时(由MaxTenuringThreshold决定，默认15)后, 存入老年代
  * 2.幸存者0区(**Survivor** 0 Space, 也叫S0 或 from区)：每次GC也会进行复制清空互换的过程
  * 3.幸存者1区(Survivor 1 Space，也叫S1 或 to区)：与S0区机制相同
* 2.老年代(养老区ParOldGen)：当对象超过内存阈值后，开启Full GC(也叫FGC或重GC或全局GC、MajorGC)，多次FGC后无法再腾出空间，将抛出OOM(`OutOfMemoryError`)堆内存溢出错误，Major GC比 Minor GC慢上十倍左右，每次Full GC经常(不是绝对)伴随一次Minor GC
* 3.元空间Metaspace(Java7叫永久代或持久代)：
  * 用于存放JDK自身携带的Class，Interface的元数据(结构信息)，也就是运行环境必须的类信息。被装载进此区域的数据不会被GC，关闭JVM才会释放此区域所占用的内存
  * 对应方法区，虽然逻辑上JVM规范将方法区描述为堆的一个逻辑部分，但物理上不包含在堆里。**元空间是方法区的一个实现**，即方法区是接口，元空间是实现。
  * 永久代和元空间最大区别：**永久代使用JVM的堆内存，而Java8之后的元空间存在于本机物理内存**，字符串常量池也在元空间

---

## 堆内存调优

* 引用数据类型是存放在堆里,  而值数据类型存放在堆栈（结构就是栈）里，java8之后的元空间也放在了堆栈，堆栈可以认为是在JVM之外的存储空间
* 元空间存在于本机物理内存，只受本地内存限制，字符串常量池也在元空间，**减少了OOM情况**，默认最大JVM Heap堆内存-Xmx只用物理内存的1/4， 最小堆内存-Xms为物理内存的1/64
* `Runtime.getRuntime().totalMemory;`    // 获取最大堆内存,  Runtime.getRuntime()为Runtime Data Area对象

![image-20200916204743293](C:\Users\qq285\AppData\Roaming\Typora\typora-user-images\image-20200916204743293.png)

##### JVM调参（即设置堆内存）：

* 可通过工具进行JVM内存分析：可视化工具：JDK自带的监控程序 jvisualvm (命令行执行此命令) 或 jconsole 或通过 jmap -heap PID 查看
* -Xms（最小内存）应该等于-Xmx（最大内存），避免堆扩容造成的线上环境堆抖动，也就是避免GC和应用程序争抢内存而导致JVM理论值忽高忽低的问题

### 堆和栈缓存方式

堆是完全二叉树，而栈是LIFO的数据结构

①栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

②堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

# GC

### GC算法（分代收集算法）

* 1.引用计数法(了解即可)：每次GC一个对象被引用就+1，没被引用-1，当为0时就清除。System.gc 不会立刻开启GC
* 2.复制算法（Copying）：**年轻代**中使用的Minor GC采用的主要是复制算法
  * 是什么：Minor GC的复制过程用到的算法，复制时内存分为两块，一块移动到to区，另一块被清除
  * 优缺点：优点是效率高，不会产生内存碎片，缺点是耗费空间

* 3.标记清除：**老年代**一般是由标记清除或者标记清除与标记整理的混合实现
* 是什么：先扫描并标记要回收的对象，接着再扫描一次，然后统一回收这些标记的对象
  
* 优缺点：优点是不需要额外空间，缺点是两次扫描耗时严重，时间是minor GC的十倍左右，会产生内存碎片
  
* 4.标记压缩（标记整理）：
  * 是什么：相当于标记清除，加上移动对象使内存碎片清除
    * 优缺点：优点：标记清除的优点+无内存碎片    缺点：耗时最长
* 标记清除压缩：标记清除和标记压缩的结合，不同的是：进行多次GC后才压缩，不算入四大算法

* 没有最好的算法，只有根据每一代GC的特性来采用对应的算法，因此叫分代收集算法

---

### JMM（Java内存模型）：可见性、原子性、有序性

JVM是一种抽象概念，描述一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段  、静态字段和守城数组对象的元素）的访问方式

* volatile是jVM提供的轻量级同步机制，保证了可见性和有序性，不保证原子性
* 1.可见性：就是个通知机制，一个线程对共享变量的修改，能及时的被其他线程看到
* 2.原子性：操作不可拆分，要么全成功，要么就不做
* 3.有序性：如果在本线程内观察，所有操作都是有序的
* JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(也叫栈空间)，工作内存是每个线程的私有数据区域
* JMM规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，再对变量进行操作，完成后再将变量写回主内存 。不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成

## 垃圾回收器的四种方式

###### 一 serial 串行垃圾回收

它为**单线程环境**设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境

###### 二 Parallel 并行垃圾回收

**多个垃圾收集线程并行工作**，此时用户线程是暂停的，适用于科学计算/大数据处理首台处理等弱交互场景

###### 三 CMS (ConcurrentMarkSweep)并发垃圾回收

**用户线程和垃圾收集线程同时执行**（不一定是并行，可能交替执行），**不需要停顿用户线程**,互联网公司多用它，适用对响应时间有要求的场景

###### 四.G1垃圾回收器（G1 Garbage Collector）

**G1**垃圾回收**将堆内存分割成不同的区域**然后**并发的对其进行垃圾回收**

## 七大垃圾回收器

### 一 Serial收集器

一个**单线程**的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。

串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在进行垃圾收集过程中可能会产生较长的停顿（Stop-The-World”状态）。虽然在**收集垃圾过程中需要暂停所有其他的工作线程**，但是它简单高效，**对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。**

![img](../../../../Software/Typora/Picture/17502375-85148316bc8f4711.png)

### 二 ParNew（并行）收集器

使用**多线程**进行垃圾回收，在垃圾收集时，会**Stop-the-World暂停其他所有的工作线程直到它收集结束**。

可用 -XX:ParallelGCThreads限制线程数量,默认开启和Cpu**数目相同的线程数**

![img](../../../../Software/Typora/Picture/17502375-a4ed361bd0024bb8.png)

### 三 Parallel Scavenge收集器

![img](../../../../Software/Typora/Picture/17502375-089b6acde103d483.png)

![img](../../../../Software/Typora/Picture/17502375-de17373e196bc9e2.png)

### 四 Parallel Old收集器

Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的**标记-整理**算法，Parallel Old收集器在JDK1.6才开始提供。
 |在JDK1.6之前，新生代使用ParallelScavenge 收集器只能搭配年老代的，Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（Parallel Scavenge+Serial Old）
 Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。在JDK1.8及后（Parallel Scavenge+Parallel Old）
 **JVM常用参数：**
 -XX：+UseParallelOldGC 使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代Parallel Old

### 五 并发标记清除GC(CMS)

![img](../../../../Software/Typora/Picture/17502375-046e426c1c9b9093.png)

![img](../../../../Software/Typora/Picture/17502375-2e45fc7662d0558c.png)

CMS收集器（Concurrent Mark Sweep：并发标记清除）**是一种以获取最短回收停顿时间为目标的收集器。**
 适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，**希望系统停顿时间最短。**
 CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。

**CMS优缺点**
 优点: **并发收集低停顿**
 缺点:

- 由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则**CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间**
- 标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。**CMS也提供了参数来指定多少次CMS收集之后，进行一次压缩的Full GC。**(-XX:CMSFullGCsBeForeCompaction（默认0，即每次都进行内存整理）)

### 六 serial old

Serial Old 题Serial垃圾收集器老年代版本，它同样是个单线程的收集器，使用**标记-整理**算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。
 在Server模式下，主要有两个用途（了解，版本已经到8及以后）：
 1.在JDK1.5之前版本中与新生代的Parallel Scavenge 收集器搭配使用。（Parallel Scavenge+Serial Old）
 2.作为老年代版中使用CMS收集器的后备垃圾收集方案。

### 七 G1垃圾回收器

**我们知道G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。**
 另外，它还具有以下特性：

- 像CMS收集器一样，能与应用程序线程并发执行。
- 整理空闲空间更快。
- 需要更多的时间来预测GC停顿时间。
- 不希望牺牲大量的吞吐性能。
- 不需要更大的Java Heap。

**G1收集器的设计目标是取代CMS收集器**，它同CMS相比在以下方面表现的更出色：
 G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。
 **G1的Stop The World（STW）更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。**

![img](../../../../Software/Typora/Picture/17502375-f916866da7f327f6.png)

##### G1底层原理

化整为零，避免全内存扫描，只需要**按照区域**来进行扫描即可**。
**详解region区域化垃圾收集器

![img](../../../../Software/Typora/Picture/17502375-0b39ac4f94664572.png)

**G1回收**
 针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片

- Eden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部会晋升到Old区
- Survivor区的数据移动到新的Survivor区，部会数据晋升到Old区
- 最后Eden区收拾干净了，GC结束，用户的应用程序继续执行。

![img](../../../../Software/Typora/Picture/17502375-5a87dbadc7c36b74.png)

![img](../../../../Software/Typora/Picture/17502375-fc94fa1f571810d5.png)


 [ ](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Faspirant%2Fp%2F8663872.html)[G1 垃圾收集器架构和如何做到可预测的停顿(阿里)](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Faspirant%2Fp%2F8663872.html)

> G1的另一个显著特点他能够让用户设置应用的暂停时间，为什么G1能做到这一点呢？也许你已经注意到了，**G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收**，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以**垃圾回收时间是不可控的,G1通过控制回收的内存大小来大概可以满足这个停顿时间**

### GC选择垃圾收集器

![在这里插入图片描述](../../../../Software/Typora/Picture/20190604210624739.png)

![在这里插入图片描述](../../../../Software/Typora/Picture/20190604210732718.png)

# 面试

## 什么情况下会发生栈内存溢出？

1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；
 2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用可能会出现该问题；
 3、调整参数-xss去调整jvm栈的大小

## 一次完整的GC

java堆 = 新生代+老年代；
 新生代 = Eden + Suivivor（S0 + S1），默认分配比例是8:1:1;
 当Eden区空间满了的时候，就会触发一次Minor GC，以收集新生代的垃圾，存活下来的对象会被分配到Survivor区
 大对象（需要大量连续内存空间的对象）会直接被分配到老年代
 如果对象在Eden中出生，并且在经历过一次Minor GC之后仍然存活，被分配到存活区的话，年龄+1，此后每经历过一次Minor GC并且存活下来，年龄就+1，当年龄达到15的时候，会被晋升到老年代；
 当老年代满了，而无法容纳更多对象的话，会触发一次full gc；full gc存储的是整个内存堆（包括年轻代和老年代）
 Major GC是发生在老年代的GC，清理老年区，经常会伴随至少一次minor gc；

## Java中的垃圾回收算法

java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法；
 标记清除法：
 第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
 第二步：在遍历一遍，将所有标记的对象回收掉；
 特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；

标记整理法：
 第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
 第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉；
 特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；

复制算法：
 将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除；
 特点：不会产生空间碎片；内存使用率极低；

分代收集算法：
 根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；

## 如何判断一个对象是否存活？

判断一个对象是否存活，分为两种算法1：引用计数法；2：可达性分析算法；
 #### 引用计数法：
 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收；
 缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；

#### 可达性分析法
 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：

虚拟机栈中引用的对象、 方法区类静态属性引用的变量、方法区常量池引用的对象、本地方法栈JNI引用的对象
当一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；第一次标记：判断当前对象是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则进行第二次标记；第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃；如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；

## 有哪几种垃圾回收器，有哪些优缺点？cms和g1的区别？

垃圾回收器主要分为以下7种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；
 Serial:
 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。

Serial Old：
 Serial收集器的老年代版本，单线程收集器，使用标记整理算法。

Parallel New:
 Serial收集器的多线程版本，也需要stop the world，复制算法.

Parallel Old：
 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。

Parallel Scavenge:
 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；

CMS:
 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；

G1:
 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；
 G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；

## 类加载

虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象；

类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；
 类加载器分为以下四种：
 启动类加载器：
 用来加载java核心类库，无法被java程序直接引用；

扩展类加载器：
 用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；

系统类加载器：
 它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的；

自定义类加载器：
 由java语言实现，继承自ClassLoader；



## 双亲委派

### 双亲委派模型

当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；

### 为什么需要双亲委派模型

为了防止内存中出现多个相同的字节码；
因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性；

### 怎么打破双亲委派模型

自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法；

### 强引用、软应用、弱引用、虚引用的区别？

强引用：强引用是我们使用最广泛的引用，如果一个对象具有强引用，那么垃圾回收期绝对不会回收它，当内存空间不足时，垃圾回收器宁愿抛出OutOfMemoryError，也不会回收具有强引用的对象；我们可以通过显示的将强引用对象置为null，让gc认为该对象不存在引用，从而来回收它；

软引用：软应用是用来描述一些有用但不是必须的对象，在java中用SoftReference来表示，当一个对象只有软应用时，只有当内存不足时，才会回收它；
 软引用可以和引用队列联合使用，如果软引用所引用的对象被垃圾回收器所回收了，虚拟机会把这个软引用加入到与之对应的引用队列中；

弱引用：弱引用是用来描述一些可有可无的对象，在java中用WeakReference来表示，在垃圾回收时，一旦发现一个对象只具有软引用的时候，无论当前内存空间是否充足，都会回收掉该对象；
 弱引用可以和引用队列联合使用，如果弱引用所引用的对象被垃圾回收了，虚拟机会将该对象的引用加入到与之关联的引用队列中；

虚引用：虚引用就是一种可有可无的引用，无法用来表示对象的生命周期，任何时候都可能被回收，虚引用主要使用来跟踪对象被垃圾回收的活动，虚引用和软引用与弱引用的区别在于：虚引用必须和引用队列联合使用；在进行垃圾回收的时候，如果发现一个对象只有虚引用，那么就会将这个对象的引用加入到与之关联的引用队列中，程序可以通过发现一个引用队列中是否已经加入了虚引用，来了解被引用的对象是否需要被进行垃圾回收；



##  虚拟机栈和本地方法栈为什么是私有的?

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

## 1.堆栈空间分配

 ①栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

 ②堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。





## 热加载

**热部署:** 就是容器在运行的情况下重新部署整个项目。在这种情况下一般整个内存会清空,、重新加载，但这种方式可能会造成sessin丢失等情况。
**热加载:** 就是容器状态在运行的情况下重新加载改变编译后的类。在这种情况下内存不会清空、session不会丢失，但容易造成内存溢出,或者找不到方法。

　　热部署与热加载技术想解决的问题是应用升级更新时对业务的影响，分布式集群技术可以允许机器分批重启而不影响业务。**从对业务影响的角度来说，分布式集群技术是可以替代热部署与热加载技术的。**

##### 实现原理：

热加载的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。

对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。热部署原理类似，但它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。

热部署作为一个比较灵活的机制，在实际的生产上运用相对很少，热加载则基本没有应用。

热加载这种直接修改jvm中字节码的方式是难以监控的，不同于sql等执行可以记录日志，直接字节码的修改几乎无法记录代码逻辑的变化，对既有代码行为的影响难以控制，对于越注重安全的应用，热加载带来的风险越大

#### tomcat热加载

tomcat本身默认开启了热部署方式，但热部署是直接重新加载整个应用，耗时跟重启服务器差不多，我们需要的其实是热加载，即修改了哪个class，只重新加载这一个class，这样耗时几乎为0。 对于tomcat5.x 以上版本，均已支持一定程度上得热加载，但这种方式只针对代码行级别的，也就是说如果新删方法，注解，类，或者变量时是无效的，只能重启

将tomcat server.xml文件的**context reloadable** 值置为**false** 或者在web modules中取消Auto reloading选项。或者修改eclipse中的server配置

tomcat的热加载机制不仅可以在本地debug时，tomcat的远程调试也支持热部署，通过eclipse debug远程到远程tomcat上，修改本地代码，ctrl+s后直接刷新页面后调用接口，即可发现远程tomcat已将本地代码进行了热加载。







