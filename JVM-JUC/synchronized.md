# 锁升级/ 锁膨胀

synchronized 同步锁一共具有四种状态：无锁、偏向锁、轻量级锁、重量级锁，他们会随着竞争情况逐渐升级，此过程为不可逆。所以 synchronized 锁膨胀过程其实就是**无锁 → 偏向锁 → 轻量级锁 → 重量级锁**的一个过程

#### 偏向锁

偏向**第一个**拿到锁的线程。即第一个拿到锁的线程，锁会在对象头 Mark Word 中通过 CAS **记录该线程 ID**，该线程以后每次拿锁时都**不需要进行 CAS**（指轻量级锁）。即第一个拿到锁的线程持有的锁就是偏向锁

如果该线程正在执行同步代码块时有其他线程在**竞争**（指其他线程尝试 CAS 让 Mark Word 设置自己的线程 ID），会**被升级**为轻量级锁

如果其他线程发现 Mark Word 里记的不是自己，且发现原持有偏向锁的线程已经执行完同步代码块，会尝试 CAS 把 Mark Word 中的改为自己的线程 ID。

###### 引入偏向锁的主要目的是：为了在无多线程竞争的情况下尽量减少不必须要的轻量级锁执行路径。其实在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，所以引入偏向锁就可以减少很多不必要的性能开销和上下文切换。

#### 轻量级锁

轻量级锁就是通过 **CAS** 进行加锁的。

JVM 会给线程的**栈帧**中创建一个叫**锁记录 Lock Record** 的空间，把对象头 Mark Word **复制**到该空间里（Displaced Mark Word），并通过 **CAS** 尝试把原对象头 Mark Word 中锁记录指针指向该线程中的锁记录。如果成功，表示线程拿到了锁（升级为轻量级锁）。如果失败，则进行自旋（**自旋锁**），自旋超过一定次数时升级为重量级锁，这时该线程会被内核挂起。

引入轻量级锁的主要目的是：在多线程竞争不激烈的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。需要注意的是轻量级锁并不是取代重量级锁，而是在大多数情况下同步块并不会出现严重的竞争情况，所以引入轻量级锁可以减少重量级锁对线程的阻塞带来的开销。

所以偏向锁是认为环境中不存在竞争情况，而轻量级锁则是认为环境中不存在竞争或者竞争不激烈，轻量级锁所以一般都只会有少数几个线程竞争锁对象，其他线程只需要稍微等待（自旋）下就可以获取锁，但是自旋次数有限制，如果超过该次数，则会升级为重量级锁。

#### 自旋锁

轻量级锁膨胀为重量级锁前，线程在执行 monitorenter 指令进入**等待队列**时，会通过**自旋**去尝试获得锁。

如果自旋超过一定次数时还未拿到锁，就会进入**阻塞**状态，等待内核来调度。此时会发生内核态与用户态之间的上下文切换，所以会影响性能（引入自旋锁就是为了减少这个开销）。

因为后面的线程也先进行自旋尝试获取锁，所以这对于已被阻塞的那些线程来说，会**不公平**。

#### 重量级锁

重量级锁就是通过内核来操作线程。因为频繁出现内核态与用户态的切换，会严重影响性能。

升级为重量级锁时会在堆中创建 monitor 对象，并将 Mark Word 指向该 monitor 对象。monitor 中有 cxq（ContentionList），EntryList ，WaitSet，owner

#### 对象头MarkWord的monitor对象

[![img](https://img2018.cnblogs.com/blog/720367/201909/720367-20190922214234040-354726592.png)]

synchronized 用的锁是存储在 Java 对象头里的，下图是锁状态变化的情况，在分析 synchronized 锁升级需要对照这图：

![image-20201107131158964](C:\Users\qq285\AppData\Roaming\Typora\typora-user-images\image-20201107131158964.png)

#### 锁升级的流程图

[![img](https://img2018.cnblogs.com/blog/720367/201909/720367-20190922214211591-1031710735.png)](https://img2018.cnblogs.com/blog/720367/201909/720367-20190922214211591-1031710735.png)



### 锁降级

Hotspot 在 1.8 开始有了锁降级。在 STW 期间 JVM 进入安全点时如果发现有闲置的 monitor（重量级锁对象），会进行锁降级。

[Java锁优化--JVM锁降级](https://www.jianshu.com/p/9932047a89be)



#### 为什么锁信息存放在对象头里？

> [死磕Synchronized底层实现--概论](https://github.com/farmerjohngit/myblog/issues/12) 中：
>
> 因为在Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。一种很直观的方法是，用一个全局map，来存储这个映射关系，但这样会有一些问题：需要对map做线程安全保障，不同的`synchronized`之间会相互影响，性能差；另外当同步对象较多时，该map可能会占用比较多的内存。
>
> 所以最好的办法是将这个映射关系存储在对象头中，因为对象头本身也有一些hashcode、GC相关的数据，所以如果能将锁信息与这些信息**共存**在对象头中就好了。

也就是说，如果用一个全局 map 来存对象的锁信息，还需要对该 map 做线程安全处理，不同的锁之间会有影响。所以直接存到对象头。

# 1.6锁优化











