[TOC]

# 哈希表

也叫散列表，本质是数组

一般来说，实现哈希表我们可以采用两种方法：

1、数组+链表

2、数组+二叉树

# 哈希冲突的解决方案

#### **1.开放寻址法**

这里所说的开放寻址法其实简单来说就是，既然位置被占了，那就另外再找个位置不就得了，既然当前位置被占用了，我们就看看该位置的后一个位置是否可用，如果没有被占用，那就放到这里呗，当然，也有可能2的位置也被占用了，那咱就继续往下找，看看3的位置，一次类推，直到找到空位置。

对了，Java中的ThreadLocal就是利用了开放寻址法。

* 线性探测在散列：往后移动x个位置
* 平方探测再散列：平方后移动位置
* 随机探测在散列：伪随机数列

**2.链地址法**

产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据，形成链表，HashMap的哈希冲突解决方案就是应用了链地址法

**3.公共溢出区法**
建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。
**4.再散列法（再哈希）**
准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……
重点了解一下开放定制法和链地址法



# 哈希算法









# 一致性哈希

在一致性哈希算法中，整个哈希空间是一个虚拟圆环。

有4个存储对象 Object A、B、C、D，经过对 Key 的哈希计算后，它们的位置如下：

![image-20200922101320565](C:\Users\qq285\AppData\Roaming\Typora\typora-user-images\image-20200922101320565.png)

 对于各个 Object，它所真正的存储位置是按顺时针找到的第一个存储节点。例如 Object A 顺时针找到的第一个节点是 Node A，所以 Node A 负责存储 Object A，Object B 存储在 Node B。

假设 Node C 节点挂掉了，Object C 的存储丢失，那么它顺时针找到的最新节点是 Node D。也就是说 Node C 挂掉了，受影响仅仅包括 Node B 到 Node C 区间的数据，并且这些数据会转移到 Node D 进行存储。

 同理，假设现在数据量大了，需要增加一台节点 Node X。Node X 的位置在 Node B 到 Node C 中间，那么受到影响的仅仅是 Node B 到 Node X 间的数据，它们要重新落到 Node X 上。

所以一致性哈希算法对于容错性和扩展性有非常好的支持。但一致性哈希算法也有一个严重的问题，就是数据倾斜。

如果在分片的集群中，节点太少，并且分布不均，一致性哈希算法就会出现部分节点数据太多，部分节点数据太少。也就是说无法控制节点存储数据的分配。





# 哈希槽

基本思想：
 （1）一共有16384个槽，每台服务器分管其中的一部分
 （2）插入一个数据的时候，先根据CRC16算法计算key对应的值，然后用该值对16384取余数（即CRC16(key) mod 16384），确定将数据放到哪个槽里面
 （3）在增加的时候，之前的节点各自分出一些槽给新节点，对应的数据也一起迁出
 （4）客户端可以向任何一个Redis节点发送请求，然后由节点将请求重定向到正确的节点上

为什么要选择的槽是16384个呢？
 crc16会输出16bit的结果，可以看作是一个分布在0-2^16-1之间的数，redis的作者测试发现这个数对2^{14}求模的会将key在0-2^{14-1}之间分布得很均匀，因此选了这个值。

![image-20200922101920607](C:\Users\qq285\AppData\Roaming\Typora\typora-user-images\image-20200922101920607.png)

redis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。

首先哈希槽其实是两个概念，第一个是哈希算法。redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。

redis cluster 包含了16384个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。

另外在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。

但一定要注意的是，对于槽位的转移和分派，redis 集群是不会自动进行的，而是需要人工配置的。所以 redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。





